{
  "language": "Solidity",
  "sources": {
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Dashboard.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\nimport 'base64-sol/base64.sol';\n\nerror Dashboard__NotEnoughETHToAddPost();\nerror Dashboard__NotEnoughETHToBuyItemFromThePost();\nerror Dashboard__NotItemExist();\n\ncontract Dashboard {\n  address private immutable i_owner;\n  uint256 private immutable i_minEntranceFee;\n  uint256 public totalPosts;\n  uint256[] public postIds;\n  string public constant base64Prefix = 'data:image/svg+xml;base64,';\n\n  constructor(uint256 minEntranceFee) payable {\n    i_owner = payable(msg.sender);\n    i_minEntranceFee = minEntranceFee;\n  }\n\n  event ItemAdded(\n    address indexed sender,\n    string description,\n    string title,\n    uint256 price,\n    uint256 id,\n    bool isPrior,\n    string image\n  );\n\n  event ItemBuyed(address indexed buyer, uint256 id, uint256 price);\n\n  struct Post {\n    address sender;\n    string description;\n    string title;\n    uint256 price;\n    uint256 id;\n    string image;\n    bool isPrior;\n  }\n\n  mapping(uint256 => Post) posts;\n\n  function addPost(\n    string memory _description,\n    string memory _title,\n    string memory _image,\n    uint256 _price,\n    bool _checkInput\n  ) public payable {\n    if (msg.value < i_minEntranceFee) {\n      revert Dashboard__NotEnoughETHToAddPost();\n    }\n\n    Post storage newPost = posts[totalPosts];\n\n    newPost.description = _description;\n    newPost.title = _title;\n    newPost.price = _price;\n    newPost.image = _image;\n    newPost.sender = msg.sender;\n    newPost.id = totalPosts;\n    newPost.isPrior = _checkInput == true ? true : false;\n    postIds.push(totalPosts);\n    emit ItemAdded(msg.sender, _description, _title, _price, totalPosts, _checkInput, _image);\n\n    totalPosts += 1;\n  }\n\n  function BuyItemFromThePost(uint256 postId) public payable {\n    if (posts[postId].sender == address(0)) {\n      revert Dashboard__NotItemExist();\n    }\n    if (msg.value < posts[postId].price) {\n      revert Dashboard__NotEnoughETHToBuyItemFromThePost();\n    }\n\n    payable(posts[postId].sender).transfer(msg.value);\n    delete posts[postId];\n    emit ItemBuyed(msg.sender, postId, msg.value);\n  }\n\n  function getMinEntranceFee() external view returns (uint256) {\n    return i_minEntranceFee;\n  }\n\n  function getTotalPosts() external view returns (uint256) {\n    return totalPosts;\n  }\n\n  function getPostIds() external view returns (uint256[] memory) {\n    return postIds;\n  }\n\n  function getPost(uint256 id) external view returns (Post memory) {\n    return posts[id];\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}